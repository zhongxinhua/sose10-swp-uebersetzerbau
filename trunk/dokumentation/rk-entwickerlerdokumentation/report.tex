\documentclass[10pt,a4paper,ngerman,titlepage,tocindentauto]{article}

\usepackage{jhla4}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{color}
\usepackage[colorlinks=true,breaklinks=true,linkcolor=darkblue,urlcolor=darkblue]{hyperref}
\usepackage{ngerman}
\usepackage{times}
\usepackage{graphicx}
\usepackage{tocstyle}
\usepackage{multicol}
\usepackage{listings}

\usetocstyle{allwithdot}
\definecolor{darkblue}{rgb}{0,0,.5}

\renewcommand{\listfigurename}{Abbildungsverzeichnis}
\renewcommand{\lstlistingname}{Quelltext}
\renewcommand{\lstlistlistingname}{Quelltextverzeichnis}

%% Hier schreibt man die PDF Eigenschaften hinein:
\hypersetup{
	pdftitle={Software Projekt Uebersetzerbau 2010: Entwicklerdokumentation},
	pdfauthor={Rene Kijewski},
	pdfsubject={},
	pdfcreator={},
	pdfproducer={},
	pdfkeywords={},
	pdfkeywords={}
}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\newcommand{\xmlNote}[2]{\footnote{Spezifikation zu \href{http://www.w3.org/TR/2008/REC-xml-20081126/\#{#1}}{\texttt{#2}}.}}
\newcommand{\link}[1]{\href{#1}{#1}}

\begin{document}
	\begin{titlepage}
		\title{Softwareprojekt Übersetzerbau: \\ Entwicklerdokumentation} 
		\author{René Kijewski} 
		\date{18. Juli 2010}
		
		\maketitle
	\end{titlepage}
	
	\begin{abstract}
		Das Softwareprojekt 2010 setzte sich zum Ziel, einen XML- nach Java-Source-Code-Übersetzter
		zu schreiben.
		
		Dieses Dokument erklärt im Speziellen die Komponenten XML-Lexer, Statement-Lexer
		und die Symboltabelle. Es richtet sich an Entwickler und enthält deshalb gegebenenfalls
		Jargon und versucht auch nicht, Sachverhalte zu vereinfachen.
		
		Die entsprechende Kundenpräsentation, die sich nicht an Programmierer richtet, steht unter
		\link{https://dev.spline.de/svn/ss10-swp-uebersetzerbau/trunk/dokumentation/rk-kundenpraesentation/rk-kundenpraesentation.pdf}
		zur Verfügung.
	\end{abstract}

	{
		\pagestyle{empty}
		\tableofcontents
		\newpage
	}
	
	\parskip 7pt plus 5pt minus 3pt
	
	\setcounter{page}{1}
	\section{Einleitung}
		Das Softwareprojekt Übersetzerbau 2010 machte es sich zur Aufgabe, eine selbst-erdachte Programmiersprache
		zu spezifizieren und einen Compiler für diese zu Implementieren.
		
		Die Projektgruppe, bestehend aus – in alphabetischer Ordnung –
			Alexander Rau,
			Ansgar Schneider,
			Igor Merkulow,
			Markus Rudolph,
			René Kijewski und
			Stefan Meißner,
		entschied sich, eine XML-artige Eingabesprache zu benutzen, die
		\href{http://java.sun.com/javase/6/}{Java-SE-6}-kompatiblen Sourcecode ausgibt.
		Dementsprechend wurde auch Java 1.6 als Programmiersprache gewählt.
		Als einheitliche Programmierungebung wurde \href{http://www.eclipse.org/galileo/}{Eclipse Galileo} verwandt.
		Apache \href{http://subversion.apache.org/}{Subversion}, gehostet bei \href{http://dev.spline.de/}{Spline}, wurde als
		Versionskontrollsystem benutzt. Der Quelltext kann von \link{https://dev.spline.de/svn/ss10-swp-uebersetzerbau/}
		heruntergeladen werden.
		
		Ich übernahm die Komponenten XML- und Statement-Lexer, sowie die Implementierung einer Symboltabelle.
		
		Bei den von mir implementierten Teilprojekten achtete ich auf hohe Wiederverwendbarkeit
		und versuchte, eine Benutzung besonders einfach zu gestalten. So legte ich größeren Wert darauf,
		dass Weiternutzer die Komponenten ohne lange Einlesezeit benutzen können als auf besonders große
		Performanz. Dieser Ansatz musste leider später aufgewicht werden. In den Abschnitten
		\hyperlink{Arbeitsverlauf}{Arbeitsverlauf} und \hyperlink{Abschlussbemerkungen}{Abschlussbemerkungen}
		finden Sie weitere Informationen dazu.
		
		Um den Einstieg in die Nutzung zu Vereinfachen, verwandte ich ausgiebig die verbreitete Entwurfsmuster,
		vorrangig das \href{http://c2.com/cgi/wiki?IteratorPattern}{\em Iterator-Patter} und die
		\href{http://c2.com/cgi/wiki?FactoryMethodPattern}{\em Factory-Methode}.
		Beide Pattern werden im Buch {\em Design Patterns: Elements of Reusable Object-Oriented Software}%
		\footnote{ISBN \href{https://portal.d-nb.de/opac.htm?method=simpleSearch&query=0201633612}{0-201-63361-2}}
		beschrieben und sind deshalb vielen Entwicklern von objektorientiertem Code geläufig.
		
		Die einzelnen Komponenten trennen so weit wie möglich zwischen Interface und Implementierung.
		Dies sollte es bei einer späteren Weiterarbeit an den Projekt vereinfachen, die Komponenten
		auszutauschen. Bei der Spezifikationsphase überlegten wir uns unter anderem, dass auch eine
		Compilierung in Java-Bytecode nativ möglich sein sollte.%
		\footnote{Das heißt, dass wir nicht von \texttt{javac} abhängig sein wollten.}
		Zudem sollte auch die Ausgabesprache auswechselbar sein, so dass nur das Kernstück,
		der Syntaxbaum, sowie das Interface der weiteren Komponenten, also Symboltabelle und Builder
		unveränderlich wäre.
		
	\section{Teilprojekte}
		Die einzelnen Teilprojekte sind für sich allein verwendbar – die Verzahnung
		mit anderen Komponenten ist minimal –, da sie jeweils am Anfang der Bearbeitungskette stehen.
		
		\begin{figure}[ht]
			\caption[Verlaufdiagramm]{Verlaufdiagramm (in diesem Dokument beschriebene Komponenten hervorgehoben)}
			\fbox{\centering
				\includegraphics[width=1\textwidth]{flowchart/Diagram1.pdf}
			}
		\end{figure}
		
		Die Lexer-Komponenten benutzen jeweils einen Zeichenstrom als Eingabe. Die Rückgabedaten speichern die
		Stelle im Eingabestrom an der sie standen, so dass spätere Komponenten, wenn sie einen Fehler
		in der Eingabe feststellen, eine geeignete Meldung samt Position ausgeben können.
		Die Symboltabelle verwendet dasselbe Interface, um die Eingabeposition zu speichern, jedoch ist
		die Bedeutung an dieser Stelle wahrscheinlich geringer als bei den Lexern.
		
		\subsection{XML-Lexer}
			Der XML-Lexer {\em xmlNodeStream} vereinfacht die Arbeit des DOM-Parsers, indem er die syntaxtischen
			Komponenten des Eingabestromes auftrennt, das heißt {\em tokenized}.
			Die erkannten Komponenten sind Textknoten, Kommentare, Tags, Endtags, Attribute und Processing instructions.
			
			Als Eingabeformat wird XML 1.0 verwendet.%
			\footnote{\href{http://www.w3.org/TR/2008/REC-xml-20081126/}{Extensible Markup Language (XML) 1.0 (Fifth Edition)}}
			Es wurden bewusst Eineinfachungen jedenüber dem W3-Standard vorgenommen. Unter anderem sind
			nicht wohlgeformte Ausdrücke nach Art \verb|<tag attr="a < b"/>| erlaubt.
			Dieses Beispiel wäre aufgrund des Kleiner-Als-Zeichens im Attributewert
			nach der Spezifikation verboten.\xmlNote{NT-AttValue}{AttValue}
			
			Die API des {\em xmlNodeStreams} ist an {\em StAX}, der \href{http://stax.codehaus.org/}{Streaming API for XML},
			angelehnt. StAX hat sich seit der Spezifikation im \href{http://jcp.org/en/jsr/detail?id=173}{JSR 173} aus
			dem Jahr 2006 als Standard für einfaches Parsen von XML-Eingaben etabliert.
			xmlNodeStream besitzt nicht dieselbe Mächtigkeit wie StAX und erfüllt in Folge dessen
			nicht die komplette Spezifikation des W3-Consortiums, da der XML-Prolog\xmlNote{xmldoc}{prolog}
			nicht als solcher verstanden wird:
			\begin{itemize}
				\item
					Die XML-Deklaration\xmlNote{NT-XMLDecl}{XMLDecl} wird als
					Processing instruction\xmlNote{NT-PI}{PI} verstanden.
				\item
					Die Doctype-Deklaration\xmlNote{NT-doctypedecl}{doctypedecl} wird nicht unterstützt.
			\end{itemize}
			Konkretere Informationen über den Informationsfluss stehen in der \hyperlink{XML-Lexer-API}{API-Referenz}.
			
			Der XML-Lexer überprüft die Eingabe nicht auf Wohlgeformtheit, das heißt, auch
			\verb|<a></b>| würde nicht nicht als Fehler erkannt. Dies ist eine bewusste Designentscheidung,
			die einerseits den Overhead durch eine solche Überprüfung verhindern soll – der DOM-Parser
			führt eh über eine Überprüfung durch – und andererseits die Anwendungsmöglichkeiten der Implementierung
			verbreitern soll: Gewöhnliche Webseiten sind selten wohlgeformtes XML. Dadurch,
			dass {\em xmlNodeStream} agnostisch gegenüber Strukturfehlern ist, wäre er auch zum
			Lexen von Internetseiten geeignet. Fehler wie fehlende abschließende Anführungszeichen werden
			jedoch nicht übergangen, da sie eine aktive Fehlerkorrektur erforderten.
			
			{\em xmlNodeStream} implementiert das Iterator-Interface Javas, wodurch der Einstieg in die
			Benutzung vereinfacht werden soll.
			
			\subsubsection*{Beispiel}
				\begin{lstlisting}[frame=single,language=XML,caption=Beispiel.xml]
<?xml version="1.0"?>
<module name="Test">
	Inhalt
</module>
				\end{lstlisting}
				Die Eingabedatei obenstehende XML-Datei würde folgendermaßen erkannt:
				\begin{itemize}
					\item Processing instruction mit dem Namen \verb|xml| und Wert \verb|version="1.0"|.
					\item Öffendes Tag mit dem Namen \verb|module|.
					\item Attribute mit dem Namen \verb|name| mit dem Wert \verb|Test|.
					\item Textknoten mit dem Wert \verb|Inhalt|.
					\item Schließendes Tag mit dem Namen \verb|module|.
				\end{itemize}
				An diesem Beispiel Erkennt man, dass das jedes eingelesene Token ein Tripel aus
				(Typ, Name und Wert ist, wobei Name und/oder Wert auch leer beziehungsweise null sein können.
			
			\begin{figure}[ht]
				\caption[Übergangstabelle der Eingabedaten]{\hypertarget{Uebergangsdiagramm_XML_Lexer}{Übergangstabelle der Eingabedaten}}
				\fbox{\centering
					\includegraphics[width=1.4\textwidth,angle=90]{xml/xml.pdf}
				}
			\end{figure}
			
		\subsection{Statement-Lexer}
			Der Statement-Lexer hat eine ähnliche Aufgabe wie der XML-Lexer: Einen Eingabestrom in seine
			Komponenten auftrennen. Das Lexen der Statements ist die Vorstufe zum Parsen.
			
			Der Statement-Lexer verwendet das Iterator-Interface, wobei die Rückgabedaten
			Tupel aus dem Typen des Datums und eventuell einem zugehörigen Wert, zum Beispiel bei Strings.
			In der derzeitigen Implementierung gibt es 33 Arten von erkannten Token, sowie zwei
			Statuscodes für das Eingabeende beziehungsweise bei lexikalisch fehlerhaften Eingaben.
			Der Umfang der erkannten Eingabefehler ist gering; die Fehlererkennung geschieht im
			{\em Statement-Parser}. Als Feher würde unter anderem ,,\verb|1a|`` erkannt; ,,\verb|a b c|`` hingegen nicht.
			
			Die Syntax der Statements lehnt sich an Java\,SE\,6 an. Da Javas Operatoren nur ein oder
			zwei Zeichen lang sind\footnote{Der Operator \texttt{{>}>{>}} wird nicht verstanden.} und es keine Zustände wie beim
			Lexen von XML-Daten wird, wird keine Übergangstabelle benutzt, sondern ein \verb|switch|- und
			\verb|if|-Konstrukt. Dies vereinfacht im Allgemeinen sowohl das Lesen und Schreiben des Lexers,
			erschwert jedoch Spezialfälle. So wird zum Beispiel zum Erkennen der Token \verb|new| und
			\verb|null| auf Tricks wie Push-Back-Buffer zurückgegriffen.
			Ein entscheidender Vorteil ist jedoch, dass das Einlesen der Daten wesentlich schneller
			als beim XML-Lexer geschieht.
	
		\subsection{Symboltabelle}
			TODO
	
	\section[Arbeitsverlauf]{\hypertarget{Arbeitsverlauf}{Arbeitsverlauf}}
		Die Komponente des XML-Lexern wurde bereits am 30. April begonnen und ist deshalb
		wohl am ausführlichsten geprüft. Die Aufgabe des Statement-Lexers wiederum wurde
		am 19. Mai begonnen und die Arbeit an der Symboltabelle wurde am 28. Mai aufgenommen,
		wudurch gerade für die letzte Aufgabe ein erheblicher Zeitdruck bestand.
	
		\subsection{XML-Lexer}
			Die Arbeit am XML-Lexer verlief Verhältnismäßig zielgerichtet. In der Vorlesung
			Übersetzerbau wurde ausgiebig erklärt, wie ein Parser geschrieben wird, so dass
			sich die tatsächliche Umsetzung als einfach erwies. Probleme ergaben sich nur,
			wenn ich Übergänge im Zustandsdiagramm (siehe \hyperlink{Uebergangsdiagramm_XML_Lexer}{Abbildung 2})
			übersah, weshalb ich sehr schnell dazu überging, das Diagramm in der Sprache
			\href{http://www.graphviz.org/doc/info/lang.html}{DOT} festzuhalten. Zeichnungen auf
			dem Papier erwiesen sich nicht als sachdienlich.
			
			TODO
	
		\subsection{Statement-Lexer}
			TODO
	
		\subsection{Symboltabelle}
			TODO
	
	\section{Offene Baustellen}
		TODO
	
		\subsection{XML-Lexer}
			TODO
	
		\subsection{Statement-Lexer}
			TODO
	
		\subsection{Symboltabelle}
			TODO
	
	\section[Abschlussbemerkungen]{\hypertarget{Abschlussbemerkungen}{Abschlussbemerkungen}}
		TODO
	
	\newpage
	\section{Anhang}
		\subsection{API-Referenz}
			TODO
		
			\subsubsection[XML-Lexer]{\hypertarget{XML-Lexer-API}{XML-Lexer}}
				TODO
		
			\subsubsection{Statement-Lexer}
				TODO
		
			\subsubsection{Symboltabelle}
				TODO
		
		\subsection{Abbildungs- und Quelltextverzeichnis}
			\listoffigures
			\lstlistoflistings
		
		\subsection{Lizenzierung}
			Teile des Quelltextes des Softwareprojektes Übersetzerbau 2010 stehen unter der Freien
			Lizenz \href{http://www.gnu.org/licenses/agpl-3.0.html}{GNU AGPL} in der Version 3.0.
			Die Dokumentation selbst, sowie die enthaltenen Graphiken, werden unter den Bedingungen
			der \href{http://www.gnu.org/licenses/fdl-1.3.html}{GNU FDL} in der Version 1.3 weitergegeben.
			Bindend sind nur die englischen Originaltext, die im nächsten Absatz angehängt sind.
			
			Sollten Sie den Quelltext zu anderen Konditionen weiterverwenden wollen, so setzen Sie
			sich bitte mit mir in Verbindung:
			\href{mailto:rene.kijewski@fu-berlin.de?subject=[SWP_CP_2010]}{rene.kijewski@fu-berlin.de}.
			
			\subsubsection{Quelltext}
			\begin{multicols}{3}
				{\tiny\input{agpl}}
			\end{multicols}
			
			\subsubsection[Dieses Dokument]{Dieses Dokument}
			\begin{multicols}{3}
				{\tiny\input{gfdl}}
			\end{multicols}
\end{document}
